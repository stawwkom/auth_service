// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/stawwkom/auth_service/internal/repository.AuthRepository -o auth_repository_minimock.go -n AuthRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/stawwkom/auth_service/internal/model"
)

// AuthRepositoryMock implements mm_repository.AuthRepository
type AuthRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, info *model.User) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, info *model.User)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mAuthRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mAuthRepositoryMockDelete

	funcGet          func(ctx context.Context, id int64) (up1 *model.UserInfo, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mAuthRepositoryMockGet

	funcGetByLogin          func(ctx context.Context, login string) (up1 *model.User, err error)
	funcGetByLoginOrigin    string
	inspectFuncGetByLogin   func(ctx context.Context, login string)
	afterGetByLoginCounter  uint64
	beforeGetByLoginCounter uint64
	GetByLoginMock          mAuthRepositoryMockGetByLogin

	funcUpdate          func(ctx context.Context, id int64, info *model.User) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, id int64, info *model.User)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mAuthRepositoryMockUpdate
}

// NewAuthRepositoryMock returns a mock for mm_repository.AuthRepository
func NewAuthRepositoryMock(t minimock.Tester) *AuthRepositoryMock {
	m := &AuthRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mAuthRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*AuthRepositoryMockCreateParams{}

	m.DeleteMock = mAuthRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*AuthRepositoryMockDeleteParams{}

	m.GetMock = mAuthRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*AuthRepositoryMockGetParams{}

	m.GetByLoginMock = mAuthRepositoryMockGetByLogin{mock: m}
	m.GetByLoginMock.callArgs = []*AuthRepositoryMockGetByLoginParams{}

	m.UpdateMock = mAuthRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*AuthRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthRepositoryMockCreate struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockCreateExpectation
	expectations       []*AuthRepositoryMockCreateExpectation

	callArgs []*AuthRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockCreateExpectation specifies expectation struct of the AuthRepository.Create
type AuthRepositoryMockCreateExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockCreateParams
	paramPtrs          *AuthRepositoryMockCreateParamPtrs
	expectationOrigins AuthRepositoryMockCreateExpectationOrigins
	results            *AuthRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockCreateParams contains parameters of the AuthRepository.Create
type AuthRepositoryMockCreateParams struct {
	ctx  context.Context
	info *model.User
}

// AuthRepositoryMockCreateParamPtrs contains pointers to parameters of the AuthRepository.Create
type AuthRepositoryMockCreateParamPtrs struct {
	ctx  *context.Context
	info **model.User
}

// AuthRepositoryMockCreateResults contains results of the AuthRepository.Create
type AuthRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// AuthRepositoryMockCreateOrigins contains origins of expectations of the AuthRepository.Create
type AuthRepositoryMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mAuthRepositoryMockCreate) Optional() *mAuthRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for AuthRepository.Create
func (mmCreate *mAuthRepositoryMockCreate) Expect(ctx context.Context, info *model.User) *mAuthRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &AuthRepositoryMockCreateParams{ctx, info}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.Create
func (mmCreate *mAuthRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectInfoParam2 sets up expected param info for AuthRepository.Create
func (mmCreate *mAuthRepositoryMockCreate) ExpectInfoParam2(info *model.User) *mAuthRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.info = &info
	mmCreate.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.Create
func (mmCreate *mAuthRepositoryMockCreate) Inspect(f func(ctx context.Context, info *model.User)) *mAuthRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by AuthRepository.Create
func (mmCreate *mAuthRepositoryMockCreate) Return(i1 int64, err error) *AuthRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &AuthRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the AuthRepository.Create method
func (mmCreate *mAuthRepositoryMockCreate) Set(f func(ctx context.Context, info *model.User) (i1 int64, err error)) *AuthRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the AuthRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the AuthRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the AuthRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mAuthRepositoryMockCreate) When(ctx context.Context, info *model.User) *AuthRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Set")
	}

	expectation := &AuthRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &AuthRepositoryMockCreateParams{ctx, info},
		expectationOrigins: AuthRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.Create return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockCreateExpectation) Then(i1 int64, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times AuthRepository.Create should be invoked
func (mmCreate *mAuthRepositoryMockCreate) Times(n uint64) *mAuthRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of AuthRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mAuthRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.AuthRepository
func (mmCreate *AuthRepositoryMock) Create(ctx context.Context, info *model.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, info)
	}

	mm_params := AuthRepositoryMockCreateParams{ctx, info}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockCreateParams{ctx, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("AuthRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreate.t.Errorf("AuthRepositoryMock.Create got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("AuthRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the AuthRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, info)
	}
	mmCreate.t.Fatalf("Unexpected call to AuthRepositoryMock.Create. %v %v", ctx, info)
	return
}

// CreateAfterCounter returns a count of finished AuthRepositoryMock.Create invocations
func (mmCreate *AuthRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of AuthRepositoryMock.Create invocations
func (mmCreate *AuthRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mAuthRepositoryMockCreate) Calls() []*AuthRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mAuthRepositoryMockDelete struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockDeleteExpectation
	expectations       []*AuthRepositoryMockDeleteExpectation

	callArgs []*AuthRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockDeleteExpectation specifies expectation struct of the AuthRepository.Delete
type AuthRepositoryMockDeleteExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockDeleteParams
	paramPtrs          *AuthRepositoryMockDeleteParamPtrs
	expectationOrigins AuthRepositoryMockDeleteExpectationOrigins
	results            *AuthRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockDeleteParams contains parameters of the AuthRepository.Delete
type AuthRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// AuthRepositoryMockDeleteParamPtrs contains pointers to parameters of the AuthRepository.Delete
type AuthRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// AuthRepositoryMockDeleteResults contains results of the AuthRepository.Delete
type AuthRepositoryMockDeleteResults struct {
	err error
}

// AuthRepositoryMockDeleteOrigins contains origins of expectations of the AuthRepository.Delete
type AuthRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mAuthRepositoryMockDelete) Optional() *mAuthRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for AuthRepository.Delete
func (mmDelete *mAuthRepositoryMockDelete) Expect(ctx context.Context, id int64) *mAuthRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &AuthRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.Delete
func (mmDelete *mAuthRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &AuthRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for AuthRepository.Delete
func (mmDelete *mAuthRepositoryMockDelete) ExpectIdParam2(id int64) *mAuthRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &AuthRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.Delete
func (mmDelete *mAuthRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mAuthRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by AuthRepository.Delete
func (mmDelete *mAuthRepositoryMockDelete) Return(err error) *AuthRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &AuthRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the AuthRepository.Delete method
func (mmDelete *mAuthRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *AuthRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the AuthRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the AuthRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the AuthRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mAuthRepositoryMockDelete) When(ctx context.Context, id int64) *AuthRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &AuthRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &AuthRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: AuthRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.Delete return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockDeleteExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.Delete should be invoked
func (mmDelete *mAuthRepositoryMockDelete) Times(n uint64) *mAuthRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of AuthRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mAuthRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.AuthRepository
func (mmDelete *AuthRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := AuthRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("AuthRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("AuthRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("AuthRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the AuthRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to AuthRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished AuthRepositoryMock.Delete invocations
func (mmDelete *AuthRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of AuthRepositoryMock.Delete invocations
func (mmDelete *AuthRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mAuthRepositoryMockDelete) Calls() []*AuthRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mAuthRepositoryMockGet struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockGetExpectation
	expectations       []*AuthRepositoryMockGetExpectation

	callArgs []*AuthRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockGetExpectation specifies expectation struct of the AuthRepository.Get
type AuthRepositoryMockGetExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockGetParams
	paramPtrs          *AuthRepositoryMockGetParamPtrs
	expectationOrigins AuthRepositoryMockGetExpectationOrigins
	results            *AuthRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockGetParams contains parameters of the AuthRepository.Get
type AuthRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// AuthRepositoryMockGetParamPtrs contains pointers to parameters of the AuthRepository.Get
type AuthRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// AuthRepositoryMockGetResults contains results of the AuthRepository.Get
type AuthRepositoryMockGetResults struct {
	up1 *model.UserInfo
	err error
}

// AuthRepositoryMockGetOrigins contains origins of expectations of the AuthRepository.Get
type AuthRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mAuthRepositoryMockGet) Optional() *mAuthRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for AuthRepository.Get
func (mmGet *mAuthRepositoryMockGet) Expect(ctx context.Context, id int64) *mAuthRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &AuthRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.Get
func (mmGet *mAuthRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AuthRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for AuthRepository.Get
func (mmGet *mAuthRepositoryMockGet) ExpectIdParam2(id int64) *mAuthRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AuthRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.Get
func (mmGet *mAuthRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mAuthRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by AuthRepository.Get
func (mmGet *mAuthRepositoryMockGet) Return(up1 *model.UserInfo, err error) *AuthRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &AuthRepositoryMockGetResults{up1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the AuthRepository.Get method
func (mmGet *mAuthRepositoryMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.UserInfo, err error)) *AuthRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the AuthRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the AuthRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the AuthRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mAuthRepositoryMockGet) When(ctx context.Context, id int64) *AuthRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Set")
	}

	expectation := &AuthRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &AuthRepositoryMockGetParams{ctx, id},
		expectationOrigins: AuthRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.Get return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockGetExpectation) Then(up1 *model.UserInfo, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times AuthRepository.Get should be invoked
func (mmGet *mAuthRepositoryMockGet) Times(n uint64) *mAuthRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of AuthRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mAuthRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.AuthRepository
func (mmGet *AuthRepositoryMock) Get(ctx context.Context, id int64) (up1 *model.UserInfo, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := AuthRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("AuthRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("AuthRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("AuthRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the AuthRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to AuthRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished AuthRepositoryMock.Get invocations
func (mmGet *AuthRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of AuthRepositoryMock.Get invocations
func (mmGet *AuthRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mAuthRepositoryMockGet) Calls() []*AuthRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mAuthRepositoryMockGetByLogin struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockGetByLoginExpectation
	expectations       []*AuthRepositoryMockGetByLoginExpectation

	callArgs []*AuthRepositoryMockGetByLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockGetByLoginExpectation specifies expectation struct of the AuthRepository.GetByLogin
type AuthRepositoryMockGetByLoginExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockGetByLoginParams
	paramPtrs          *AuthRepositoryMockGetByLoginParamPtrs
	expectationOrigins AuthRepositoryMockGetByLoginExpectationOrigins
	results            *AuthRepositoryMockGetByLoginResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockGetByLoginParams contains parameters of the AuthRepository.GetByLogin
type AuthRepositoryMockGetByLoginParams struct {
	ctx   context.Context
	login string
}

// AuthRepositoryMockGetByLoginParamPtrs contains pointers to parameters of the AuthRepository.GetByLogin
type AuthRepositoryMockGetByLoginParamPtrs struct {
	ctx   *context.Context
	login *string
}

// AuthRepositoryMockGetByLoginResults contains results of the AuthRepository.GetByLogin
type AuthRepositoryMockGetByLoginResults struct {
	up1 *model.User
	err error
}

// AuthRepositoryMockGetByLoginOrigins contains origins of expectations of the AuthRepository.GetByLogin
type AuthRepositoryMockGetByLoginExpectationOrigins struct {
	origin      string
	originCtx   string
	originLogin string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) Optional() *mAuthRepositoryMockGetByLogin {
	mmGetByLogin.optional = true
	return mmGetByLogin
}

// Expect sets up expected params for AuthRepository.GetByLogin
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) Expect(ctx context.Context, login string) *mAuthRepositoryMockGetByLogin {
	if mmGetByLogin.mock.funcGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("AuthRepositoryMock.GetByLogin mock is already set by Set")
	}

	if mmGetByLogin.defaultExpectation == nil {
		mmGetByLogin.defaultExpectation = &AuthRepositoryMockGetByLoginExpectation{}
	}

	if mmGetByLogin.defaultExpectation.paramPtrs != nil {
		mmGetByLogin.mock.t.Fatalf("AuthRepositoryMock.GetByLogin mock is already set by ExpectParams functions")
	}

	mmGetByLogin.defaultExpectation.params = &AuthRepositoryMockGetByLoginParams{ctx, login}
	mmGetByLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByLogin.expectations {
		if minimock.Equal(e.params, mmGetByLogin.defaultExpectation.params) {
			mmGetByLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByLogin.defaultExpectation.params)
		}
	}

	return mmGetByLogin
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.GetByLogin
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockGetByLogin {
	if mmGetByLogin.mock.funcGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("AuthRepositoryMock.GetByLogin mock is already set by Set")
	}

	if mmGetByLogin.defaultExpectation == nil {
		mmGetByLogin.defaultExpectation = &AuthRepositoryMockGetByLoginExpectation{}
	}

	if mmGetByLogin.defaultExpectation.params != nil {
		mmGetByLogin.mock.t.Fatalf("AuthRepositoryMock.GetByLogin mock is already set by Expect")
	}

	if mmGetByLogin.defaultExpectation.paramPtrs == nil {
		mmGetByLogin.defaultExpectation.paramPtrs = &AuthRepositoryMockGetByLoginParamPtrs{}
	}
	mmGetByLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByLogin
}

// ExpectLoginParam2 sets up expected param login for AuthRepository.GetByLogin
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) ExpectLoginParam2(login string) *mAuthRepositoryMockGetByLogin {
	if mmGetByLogin.mock.funcGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("AuthRepositoryMock.GetByLogin mock is already set by Set")
	}

	if mmGetByLogin.defaultExpectation == nil {
		mmGetByLogin.defaultExpectation = &AuthRepositoryMockGetByLoginExpectation{}
	}

	if mmGetByLogin.defaultExpectation.params != nil {
		mmGetByLogin.mock.t.Fatalf("AuthRepositoryMock.GetByLogin mock is already set by Expect")
	}

	if mmGetByLogin.defaultExpectation.paramPtrs == nil {
		mmGetByLogin.defaultExpectation.paramPtrs = &AuthRepositoryMockGetByLoginParamPtrs{}
	}
	mmGetByLogin.defaultExpectation.paramPtrs.login = &login
	mmGetByLogin.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmGetByLogin
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.GetByLogin
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) Inspect(f func(ctx context.Context, login string)) *mAuthRepositoryMockGetByLogin {
	if mmGetByLogin.mock.inspectFuncGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.GetByLogin")
	}

	mmGetByLogin.mock.inspectFuncGetByLogin = f

	return mmGetByLogin
}

// Return sets up results that will be returned by AuthRepository.GetByLogin
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) Return(up1 *model.User, err error) *AuthRepositoryMock {
	if mmGetByLogin.mock.funcGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("AuthRepositoryMock.GetByLogin mock is already set by Set")
	}

	if mmGetByLogin.defaultExpectation == nil {
		mmGetByLogin.defaultExpectation = &AuthRepositoryMockGetByLoginExpectation{mock: mmGetByLogin.mock}
	}
	mmGetByLogin.defaultExpectation.results = &AuthRepositoryMockGetByLoginResults{up1, err}
	mmGetByLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByLogin.mock
}

// Set uses given function f to mock the AuthRepository.GetByLogin method
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) Set(f func(ctx context.Context, login string) (up1 *model.User, err error)) *AuthRepositoryMock {
	if mmGetByLogin.defaultExpectation != nil {
		mmGetByLogin.mock.t.Fatalf("Default expectation is already set for the AuthRepository.GetByLogin method")
	}

	if len(mmGetByLogin.expectations) > 0 {
		mmGetByLogin.mock.t.Fatalf("Some expectations are already set for the AuthRepository.GetByLogin method")
	}

	mmGetByLogin.mock.funcGetByLogin = f
	mmGetByLogin.mock.funcGetByLoginOrigin = minimock.CallerInfo(1)
	return mmGetByLogin.mock
}

// When sets expectation for the AuthRepository.GetByLogin which will trigger the result defined by the following
// Then helper
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) When(ctx context.Context, login string) *AuthRepositoryMockGetByLoginExpectation {
	if mmGetByLogin.mock.funcGetByLogin != nil {
		mmGetByLogin.mock.t.Fatalf("AuthRepositoryMock.GetByLogin mock is already set by Set")
	}

	expectation := &AuthRepositoryMockGetByLoginExpectation{
		mock:               mmGetByLogin.mock,
		params:             &AuthRepositoryMockGetByLoginParams{ctx, login},
		expectationOrigins: AuthRepositoryMockGetByLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByLogin.expectations = append(mmGetByLogin.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.GetByLogin return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockGetByLoginExpectation) Then(up1 *model.User, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockGetByLoginResults{up1, err}
	return e.mock
}

// Times sets number of times AuthRepository.GetByLogin should be invoked
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) Times(n uint64) *mAuthRepositoryMockGetByLogin {
	if n == 0 {
		mmGetByLogin.mock.t.Fatalf("Times of AuthRepositoryMock.GetByLogin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByLogin.expectedInvocations, n)
	mmGetByLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByLogin
}

func (mmGetByLogin *mAuthRepositoryMockGetByLogin) invocationsDone() bool {
	if len(mmGetByLogin.expectations) == 0 && mmGetByLogin.defaultExpectation == nil && mmGetByLogin.mock.funcGetByLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByLogin.mock.afterGetByLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByLogin implements mm_repository.AuthRepository
func (mmGetByLogin *AuthRepositoryMock) GetByLogin(ctx context.Context, login string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetByLogin.beforeGetByLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByLogin.afterGetByLoginCounter, 1)

	mmGetByLogin.t.Helper()

	if mmGetByLogin.inspectFuncGetByLogin != nil {
		mmGetByLogin.inspectFuncGetByLogin(ctx, login)
	}

	mm_params := AuthRepositoryMockGetByLoginParams{ctx, login}

	// Record call args
	mmGetByLogin.GetByLoginMock.mutex.Lock()
	mmGetByLogin.GetByLoginMock.callArgs = append(mmGetByLogin.GetByLoginMock.callArgs, &mm_params)
	mmGetByLogin.GetByLoginMock.mutex.Unlock()

	for _, e := range mmGetByLogin.GetByLoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetByLogin.GetByLoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByLogin.GetByLoginMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByLogin.GetByLoginMock.defaultExpectation.params
		mm_want_ptrs := mmGetByLogin.GetByLoginMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockGetByLoginParams{ctx, login}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByLogin.t.Errorf("AuthRepositoryMock.GetByLogin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByLogin.GetByLoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmGetByLogin.t.Errorf("AuthRepositoryMock.GetByLogin got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByLogin.GetByLoginMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByLogin.t.Errorf("AuthRepositoryMock.GetByLogin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByLogin.GetByLoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByLogin.GetByLoginMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByLogin.t.Fatal("No results are set for the AuthRepositoryMock.GetByLogin")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetByLogin.funcGetByLogin != nil {
		return mmGetByLogin.funcGetByLogin(ctx, login)
	}
	mmGetByLogin.t.Fatalf("Unexpected call to AuthRepositoryMock.GetByLogin. %v %v", ctx, login)
	return
}

// GetByLoginAfterCounter returns a count of finished AuthRepositoryMock.GetByLogin invocations
func (mmGetByLogin *AuthRepositoryMock) GetByLoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByLogin.afterGetByLoginCounter)
}

// GetByLoginBeforeCounter returns a count of AuthRepositoryMock.GetByLogin invocations
func (mmGetByLogin *AuthRepositoryMock) GetByLoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByLogin.beforeGetByLoginCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.GetByLogin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByLogin *mAuthRepositoryMockGetByLogin) Calls() []*AuthRepositoryMockGetByLoginParams {
	mmGetByLogin.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockGetByLoginParams, len(mmGetByLogin.callArgs))
	copy(argCopy, mmGetByLogin.callArgs)

	mmGetByLogin.mutex.RUnlock()

	return argCopy
}

// MinimockGetByLoginDone returns true if the count of the GetByLogin invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockGetByLoginDone() bool {
	if m.GetByLoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByLoginMock.invocationsDone()
}

// MinimockGetByLoginInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockGetByLoginInspect() {
	for _, e := range m.GetByLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.GetByLogin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByLoginCounter := mm_atomic.LoadUint64(&m.afterGetByLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByLoginMock.defaultExpectation != nil && afterGetByLoginCounter < 1 {
		if m.GetByLoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.GetByLogin at\n%s", m.GetByLoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.GetByLogin at\n%s with params: %#v", m.GetByLoginMock.defaultExpectation.expectationOrigins.origin, *m.GetByLoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByLogin != nil && afterGetByLoginCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.GetByLogin at\n%s", m.funcGetByLoginOrigin)
	}

	if !m.GetByLoginMock.invocationsDone() && afterGetByLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.GetByLogin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByLoginMock.expectedInvocations), m.GetByLoginMock.expectedInvocationsOrigin, afterGetByLoginCounter)
	}
}

type mAuthRepositoryMockUpdate struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockUpdateExpectation
	expectations       []*AuthRepositoryMockUpdateExpectation

	callArgs []*AuthRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockUpdateExpectation specifies expectation struct of the AuthRepository.Update
type AuthRepositoryMockUpdateExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockUpdateParams
	paramPtrs          *AuthRepositoryMockUpdateParamPtrs
	expectationOrigins AuthRepositoryMockUpdateExpectationOrigins
	results            *AuthRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockUpdateParams contains parameters of the AuthRepository.Update
type AuthRepositoryMockUpdateParams struct {
	ctx  context.Context
	id   int64
	info *model.User
}

// AuthRepositoryMockUpdateParamPtrs contains pointers to parameters of the AuthRepository.Update
type AuthRepositoryMockUpdateParamPtrs struct {
	ctx  *context.Context
	id   *int64
	info **model.User
}

// AuthRepositoryMockUpdateResults contains results of the AuthRepository.Update
type AuthRepositoryMockUpdateResults struct {
	err error
}

// AuthRepositoryMockUpdateOrigins contains origins of expectations of the AuthRepository.Update
type AuthRepositoryMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originId   string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mAuthRepositoryMockUpdate) Optional() *mAuthRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for AuthRepository.Update
func (mmUpdate *mAuthRepositoryMockUpdate) Expect(ctx context.Context, id int64, info *model.User) *mAuthRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &AuthRepositoryMockUpdateParams{ctx, id, info}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.Update
func (mmUpdate *mAuthRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &AuthRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for AuthRepository.Update
func (mmUpdate *mAuthRepositoryMockUpdate) ExpectIdParam2(id int64) *mAuthRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &AuthRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id
	mmUpdate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectInfoParam3 sets up expected param info for AuthRepository.Update
func (mmUpdate *mAuthRepositoryMockUpdate) ExpectInfoParam3(info *model.User) *mAuthRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &AuthRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.info = &info
	mmUpdate.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.Update
func (mmUpdate *mAuthRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int64, info *model.User)) *mAuthRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by AuthRepository.Update
func (mmUpdate *mAuthRepositoryMockUpdate) Return(err error) *AuthRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &AuthRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the AuthRepository.Update method
func (mmUpdate *mAuthRepositoryMockUpdate) Set(f func(ctx context.Context, id int64, info *model.User) (err error)) *AuthRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the AuthRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the AuthRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the AuthRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mAuthRepositoryMockUpdate) When(ctx context.Context, id int64, info *model.User) *AuthRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Set")
	}

	expectation := &AuthRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &AuthRepositoryMockUpdateParams{ctx, id, info},
		expectationOrigins: AuthRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.Update return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockUpdateExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.Update should be invoked
func (mmUpdate *mAuthRepositoryMockUpdate) Times(n uint64) *mAuthRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of AuthRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mAuthRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.AuthRepository
func (mmUpdate *AuthRepositoryMock) Update(ctx context.Context, id int64, info *model.User) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, info)
	}

	mm_params := AuthRepositoryMockUpdateParams{ctx, id, info}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockUpdateParams{ctx, id, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("AuthRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("AuthRepositoryMock.Update got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmUpdate.t.Errorf("AuthRepositoryMock.Update got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("AuthRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the AuthRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, info)
	}
	mmUpdate.t.Fatalf("Unexpected call to AuthRepositoryMock.Update. %v %v %v", ctx, id, info)
	return
}

// UpdateAfterCounter returns a count of finished AuthRepositoryMock.Update invocations
func (mmUpdate *AuthRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of AuthRepositoryMock.Update invocations
func (mmUpdate *AuthRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mAuthRepositoryMockUpdate) Calls() []*AuthRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockGetByLoginInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetByLoginDone() &&
		m.MinimockUpdateDone()
}
